
### 缓存

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98.md)

### 在浏览器中，一个页面从输入URL到加载完成，都有哪些步骤？

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90.md)

### GET 和 POST 的区别有哪些？

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/GET%E5%92%8CPOST%E6%9C%80%E6%A0%B9%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB.md)

### 回流与重绘

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98.md)

### 浏览器的渲染渲染过程与原理

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86.md)

### 跨域

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F.md)

### 安全

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%AE%89%E5%85%A8.md)

### 登录鉴权

[戳我查看](https://blog.csdn.net/wang839305939/article/details/78713124)

### DNS 解析过程

首先了解三个概念：`根DNS服务器`、`顶级域名DNS服务器`和`权威DNS服务器`。

- **`根DNS服务器`**：返回顶级域名 DNS 服务器的 IP 地址
- **`顶级域DNS服务器`**：返回权威域名 DNS 服务器的 IP 地址
- **`权威DNS服务器`**：返回相应主机的 IP 地址

DNS 解析流程如下：

1. 浏览器在访问一个域名之前，比如`www.163.com`，就会问本地DNS服务器这个域名的IP是什么。如果是通过DHCP 配置，本地的DNS服务器由网络服务商提供。
2. 本地DNS收到来自客户端的请求。你可以想像这台服务器上缓存了一张域名与之对应IP地址的大表格。本地的DNS服务器如果缓存了这个域名的IP就直接返回，如果没有，就会问根域名服务器。根域名服务器是最高层次的，全球共有13套。它不直接用于域名解析，但能指明一条道路。
3. 根DNS收到来自本地DNS的请求，发现后缀是`.com`，说这个域名是由`.com`区域管理，我给你它的顶级域名服务器的地址，你去问问它吧。
4. 本地DNS转向问顶级域名服务器，顶级域名服务器就是大名鼎鼎的一级域名，它负责管理二级域名，比如`163.com`，所以它能提供一条更清晰的方向。
5. 顶级域名服务器说：我给你负责`www.163.com`区域的权威DNS服务器的地址，你去问它应该能问到。
6. 本地DNS转向问权威DNS服务器，`163.com`的权威DNS服务器是域名解析结果的原出处。
7. 权威DNS服务器查询后将对应的IP地址告诉本地DNS。
8. 本地DNS再将IP地址返回给客户端，客户端和目标建立连接。

![](https://img-blog.csdn.net/20180816184614744?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L1E1MjA3Nzk4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

### 三次握手的过程

1. 客户端发送一个携带**SYN**标志位的包，请求建立连接
2. 服务器响应一个携带**SYN**和**ACK**标志位的包，同意建立连接
3. 客户端再发送一个携带**ACK**标志位的包，表示连接成功，开始进行数据传输

### 四次挥手过程

1. 客户端发送一个携带**FIN**标志位的包，请求断开连接
2. 服务器响应一个携带**ACK**标志位的包，同意客户端断开连接
3. 服务器再发送一个携带**FIN**标志位的包，请求断开连接
4. 客户端最后发送一个携带**ACK**标志位的包，同意服务器断开连接

### TCP 和 UDP 有哪些区别？

1. TCP是面向连接的（如打电话前要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务，无差错、不丢失、不重复且按序到达；UDP尽最大努力交付
3. TCP面向字节流，把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用）
4. 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信

### HTTP 协议

1. **持久连接**：HTTP1.1提出了持久连接，只要通信两端的任意一端没有明确提出断开，就保持连接状态，以便下一次通信**复用**该连接，避免了重复建立和断开连接所造成的开销，加速了页面的呈现。
2. **管道化**：客户端能同时发送多个请求，服务器再按顺序一个接一个响应。
3. **状态管理**：HTTP是无状态协议，请求和响应一一对应，不会出现两个请求复用一个响应的情况。

### HTTP 请求中的 `keep-alive`

HTTP 是基于 TCP 的，每一个 HTTP 请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0 中出现了`Connection: keep-alive`，用于建立长连接。Keep-Alive 模式更加高效，因为避免了连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。

### HTTP 为什么不安全？

1. 数据以明文传递，有被窃听的风险
2. 接收到的报文无法证明是发送时的报文，不能保证完整性，因此报文有被篡改的风险
3. 不验证通信两端的身份，请求或响应有被伪造的风险

### HTTP 和 HTTPS 的区别

1. HTTPS协议需要CA申请证书，一般免费证书比较少，因而需要一定费用
2. HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4. HTTP的连接很简单，是无状态的；HTTPS协议是由**SSL+HTTP**协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全

### HTTPS

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/HTTPS.md)

### HTTPS 有哪些缺点？

1. 通信两端都需要进行加密和解密，会消耗大量的CPU、内存等资源，增加了服务器的负载
2. 加密运算和多次握手降低了访问速度
3. 在开发阶段，加大了页面调试难度。由于信息都被加密了，所以用代理工具的话，需要先解密然后才能看到真实信息
4. 用HTTPS访问的页面，页面内的外部资源都得用HTTPS请求，包括脚本中的AJAX请求

### HTTP/1.1 的不足

1. 在传输中会出现队首阻塞问题
2. 响应不分轻重缓急，只会按先来后到的顺序执行
3. 并行通信需要建立多个TCP连接
4. 服务器不能主动推送客户端想要的资源，只能被动地等待客户端发起请求
5. 由于HTTP是无状态的，所以每次请求和响应都会携带大量冗余信息

### HTTP/2.0 新特性

1. **二进制分帧层**：是HTTP/2.0性能增强的关键，它改变了通信两端交互数据的方式，原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接受帧并拼接成一条消息，再处理请求
2. **多路复用**：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个链接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务器端请求里面
3. **首部压缩**：如上文所言。前面提到过的HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
4. **服务器推送**：HTTP2.0支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是一减少HTTP请求的方法。服务器除了处理最初的请求外，还会额外推送客户端想要的资源，无需客户端发出明确的请求。

### HTTP 首部

**请求报文**

- 请求行
  - 请求类型
  - 要访问的资源
  - HTTP协议版本号
- 请求头
  - 用来说明服务器要是用的附加信息（一些键值对）
  - 例如：User-Agent、Accept、Content-Type、Connection
- 空行
  - 分割请求头与请求体
- 请求体
  - 可以添加任意的其他数据

**响应报文**

- 状态行
  - 状态码
  - 状态消息
  - HTTP协议版本号
- 消息报头
  - 说明客户端要使用的一些附加信息
  - 如：Content-Type、charset、响应的时间
- 响应正文
  - 返回给客户端的文本信息

### 301 和 302 状态码的区别

301是永久性重定向，302是暂时性重定向。

301表示旧地址A的资源已经被永久地移除了，搜索引擎在抓取新内容的同时也将旧的网址改变为重定向之后的网站。302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址**。

### 304 (Not Modified)状态码

当用户第一次请求资源A时，服务器会添加一个名为`Last-Modified`响应头，这个头说明了A的最后修改时间，浏览器会把A的内容以及最后的响应时间缓存下来，当用户第二次请求A时，在请求中包含一个名为`If-Modified-Since`请求头，它的值就是第一次请求时服务器通过`Last-Modified`响应头发送给浏览器的值，即资源A最后的修改时间。

`If-Modified-Since`请求头就是在告诉浏览器，我这里浏览器缓存的A最后修改时间是这个，你看看现在A最后修改时间是不是这个，如果还是，那么就不用响应这个请求了，我会把缓存里的内容直接显示出来。而服务器会获取`If-Modified-Since`值，与A当前的最后修改时间作对比，如果相同，则服务器返回304状态码，表示A与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明A已经改变，服务器会返回200状态码。

### 206（Partial Content） 状态码

206 代表的意思就是响应了部分内容 ，那肯定就需要有一些消息头来控制怎么通过每次的大部分内容来完成整个的接收。利用的场景也就是对大文件下载比较多，也就实现了断点续传的功能。

### readyState 0-4分别表示什么？

- `0(UNSENT)`：初始化，XMLHttpRequest 对象还没有完成初始化
- `1(OPENED)`：载入，XMLHttpRequest 对象开始发送请求
- `2(HEADERS_RECEIVED)`：载入完成，XMLHttpRequest 对象的请求发送完成
- `3(LOADING)`：解析，XMLHttpRequest 对象开始读取服务器的响应
- `4(DONE)`：数据传输已完成或传输过程中出现问题

状态码                          | 含义
-------------------------------|----------------------------------
**100(Continue)**              | 继续。客户端应继续其请求
**200(OK)**                    | 一切正常。一般用于GET和POST请求
**401(Unauthorized)**          | 请求要求用户的身份认证
**403(Forbidden)**             | 除非拥有授权否则服务器拒绝提供所请求的资源
**404(Not Found)**             | 告诉客户端所给的地址无法找到任何资源
**500(Internal Server Error)** | 服务器错误
**503(Service Unavailable)**   | 表示服务器由于在维护或已经超载而无法响应

***

### 介绍一下你对浏览器内核的理解？

主要分成两部分：**渲染引擎**和**JS引擎**

渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其他需要编辑、显示网络内容的应用程序都需要内核。

JS引擎：解析和执行JavaScript来实现网页的动态效果。

最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。

### 谈谈垃圾回收机制和内存管理

垃圾回收（Garbage Collection），简称GC。简单来讲，GC就是把内存中不需要的数据释放了，这样这部分内存就可以存放其他东西了。在JavaScript中，如果一个对象不再被引用，那么这个对象就会被GC回收。具体回收策略包括以下3种：

- 标记清除

  当从window节点遍历DOM树不能遍历到某个对象，那么这个对象就会被标记为没用的对象。由于回收机制是周期性执行的，这样，当下一个回收周期到来时，这个对象对应的内存就会被释放。

- 引用计数

  当系统中定义了一个对象后，对于这一块内存，JavaScript会记录有多少个引用指向这部分内存，如果这个数为零，则这部分内存会在下一个回收周期被释放。

- 手动释放

###  什么是Service Worker？

> 详参[这篇文章](<http://kailian.github.io/2017/03/01/service-worker>)

**Service Worker 是独立于当前页面的一段运行在浏览器后台进程里的脚本**。

Service Worker 不需要用户打开web页面，也不需要其他交互，异步地运行在一个完全独立的上下文环境，不会对主线程造成阻塞。基于Service Worker可以实现消息推送，静默更新以及地理围栏等服务。

Service Worker 提供一种渐进增强的特性，使用特性检测来渐渐增强，不会在老旧的不支持Service Worker的浏览器中产生影响。可以通过Service Worker解决让应用程序能够离线工作，让存储数据在离线时使用的问题。

### 域名发散与域名收敛

- 域名发散

  PC时代为了突破浏览器的的域名并发限制，遵循这样一条定律：**http静态资源采用多个子域名**。目的是充分利用现代浏览器的多线程并发下载能力。由于浏览器的限制，每个浏览器，允许对每个域名的连接数一般是有上限的，如下图：

  ![](https://camo.githubusercontent.com/e8881588de4903a30904e30de1fc6548ff906136/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3630383738322f3230313630342f3630383738322d32303136303430373139353130363632352d313235343234383232362e6a7067)

  上图展示了各浏览器的并行连接数（同域名），可以看到在一些浏览器内每个hostname的最大连接数基本都是6个。

  所以PC时代对静态资源优化时，通常将静态资源分布在几个不同域，保证资源最完美地分域名存储，以提供最大并行度，让客户端加载静态资源更为迅速。

  为什么浏览器要做并发限制呢？

  - 究其根本原因，在以前，服务器端的负载能力差，稍微流量大一点服务器就容易崩溃。所以为了保护服务器不被强暴到崩溃，浏览器要对最大并发数进行限制。如果每个用户的最大并发数不限制的话，服务器的负载能力会大幅下降。
  - 另外还有一个方面就是，防止**分布式拒绝服务攻击**（distributed denial-of-service attack，简称**DDoS攻击**），最基本的DDoS攻击就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。

  当然，由于建立新的请求需要一定的代价，因此需要在域名发散和域名收敛之间做权衡，通常发散的域名个数为2-4个。

- 域名收敛

  域名收敛是将静态资源只放在一个域名下面，而非发散情况下的多个域名下。域名发散可以突破浏览器的域名并发限制，那么为什么要反其道而行之呢？因为因地制宜，不同情况区别对待，域名发散是PC时代的产物，而现在进入移动互联网时代，通过无线设备访问网站，APP的用户已占据了很大一部分比例，而域名发散正是在这种情况下提出的。

  通常DNS是一个开销较大的操作，而移动端由于网络带宽和实时性、资源等的限制，这些开销对移动端的用户体验是致命的，因此需要进行域名收敛。

