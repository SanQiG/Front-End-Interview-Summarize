
### 缓存

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E7%BC%93%E5%AD%98.md)

### 在浏览器中，一个页面从输入URL到加载完成，都有哪些步骤？

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%AE%8C%E6%88%90.md)

### GET 和 POST 的区别有哪些？

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/GET%E5%92%8CPOST%E6%9C%80%E6%A0%B9%E6%9C%AC%E7%9A%84%E5%8C%BA%E5%88%AB.md)

### 回流与重绘

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%9B%9E%E6%B5%81%E4%B8%8E%E9%87%8D%E7%BB%98.md)

### 浏览器的渲染渲染过程与原理

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E6%B8%B2%E6%9F%93%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%8E%9F%E7%90%86.md)

### 跨域

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E8%B7%A8%E5%9F%9F.md)

### 三次握手的过程

1. 客户端发送一个携带**SYN**标志位的包，请求建立连接
2. 服务器响应一个携带**SYN**和**ACK**标志位的包，同意建立连接
3. 客户端再发送一个携带**ACK**标志位的包，表示连接成功，开始进行数据传输

### 四次挥手过程

1. 客户端发送一个携带**FIN**标志位的包，请求断开连接
2. 服务器响应一个携带**ACK**标志位的包，同意客户端断开连接
3. 服务器再发送一个携带**FIN**标志位的包，请求断开连接
4. 客户端最后发送一个携带**ACK**标志位的包，同意服务器断开连接

### TCP 和 UDP 有哪些区别？

1. TCP是面向连接的（如打电话前要先拨号建立连接）；UDP是无连接的，即发送数据之前不需要建立连接
2. TCP提供可靠的服务，无差错、不丢失、不重复且按序到达；UDP尽最大努力交付
3. TCP面向字节流，把数据看成一连串无结构的字节流；UDP是面向报文的，UDP没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用）
4. 每一条TCP连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信

### HTTP 协议

1. **持久连接**：HTTP1.1提出了持久连接，只要通信两端的任意一端没有明确提出断开，就保持连接状态，以便下一次通信**复用**该连接，避免了重复建立和断开连接所造成的开销，加速了页面的呈现。
2. **管道化**：客户端能同时发送多个请求，服务器再按顺序一个接一个响应。
3. **状态管理**：HTTP是无状态协议，请求和响应一一对应，不会出现两个请求复用一个响应的情况。

### HTTP 请求中的 `keep-alive`

HTTP 是基于 TCP 的，每一个 HTTP 请求都需要进行三次握手。如果一个页面对某一个域名有多个请求，就会进行频繁的建立连接和断开连接。所以HTTP 1.0 中出现了`Connection: keep-alive`，用于建立长连接。Keep-Alive 模式更加高效，因为避免了连接建立和释放的开销。但是，长时间的TCP连接容易导致系统资源无效占用，配置不当的keep-alive有时比重复利用连接带来的损失还更大。所以，正确设置keep-alive timeout时间非常重要。

### HTTP 为什么不安全？

1. 数据以明文传递，有被窃听的风险
2. 接收到的报文无法证明是发送时的报文，不能保证完整性，因此报文有被篡改的风险
3. 不验证通信两端的身份，请求或响应有被伪造的风险

### HTTP 和 HTTPS 的区别

1. HTTPS协议需要CA申请证书，一般免费证书比较少，因而需要一定费用
2. HTTP是超文本传输协议，信息是明文传输，HTTPS则是具有安全性的SSL加密传输协议
3. HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443
4. HTTP的连接很简单，是无状态的；HTTPS协议是由**SSL+HTTP**协议构建的可进行加密传输、身份认证的网络协议，比HTTP协议安全

### HTTPS

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/HTTPS.md)

### HTTPS 有哪些缺点？

1. 通信两端都需要进行加密和解密，会消耗大量的CPU、内存等资源，增加了服务器的负载
2. 加密运算和多次握手降低了访问速度
3. 在开发阶段，加大了页面调试难度。由于信息都被加密了，所以用代理工具的话，需要先解密然后才能看到真实信息
4. 用HTTPS访问的页面，页面内的外部资源都得用HTTPS请求，包括脚本中的AJAX请求

### HTTP/1.1 的不足

1. 在传输中会出现队首阻塞问题
2. 响应不分轻重缓急，只会按先来后到的顺序执行
3. 并行通信需要建立多个TCP连接
4. 服务器不能主动推送客户端想要的资源，只能被动地等待客户端发起请求
5. 由于HTTP是无状态的，所以每次请求和响应都会携带大量冗余信息

### HTTP/2.0 新特性

1. **二进制分帧层**：是HTTP/2.0性能增强的关键，它改变了通信两端交互数据的方式，原先是以文本传输，现在要先对数据进行二进制编码，再把数据分成一个一个的帧，接着把帧送到数据流中，最后对方接受帧并拼接成一条消息，再处理请求
2. **多路复用**：即连接共享，即每一个request都是用作连接共享机制的。一个request对应一个id，这样一个链接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务器端请求里面
3. **首部压缩**：如上文所言。前面提到过的HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小
4. **服务器推送**：HTTP2.0支持服务器主动推送，简单地说就是一次请求返回多个响应，这也是一减少HTTP请求的方法。服务器除了处理最初的请求外，还会额外推送客户端想要的资源，无需客户端发出明确的请求。

### HTTP 首部

首部有5种类型：**通用首部**，**请求首部**，**响应首部**，**实体首部**和**自定义首部**

1. 通用首部：既可以存在于请求中，也可以存在于响应中。
    首部|描述
    ---|---
    Request URL|请求的URL地址
    Request Method|请求方法
    Status Code|状态码
    Remote Address|路由地址
2. 请求首部：请求首部只存在于请求报文中，提供客户端的信息以及对服务器的要求。
  首部|描述
   ---|---
   Accept|可接受的MIME类型
   Accept-Charset |可接受的字符集
   Accept-Encoding |可接受的编码格式，服务器按指定的编码格式压缩数据
   Accept-Language |可接受的语言种类。<br />语言跟字符集的区别：中文是语言，中文有多种字符集，比如gb2312，gbk等
   Referer |发送请求页面的URL。<br />浏览器向服务器表明自己是从哪个URL获得当前请求中的URL
   User-Agent |用户代理信息
   Host |发送请求页面所在域
   Cache-Control |浏览器应遵循的缓存机制<br />no-cache：不要缓存的实体，要求现在从服务器去取<br />no-store：禁止资源被缓存<br />max-age：只接受Age值小于max-age值，并且没有过期的对象<br />max-stale：可以接受过去的对象，但是过期时间必须小于max-stale值
 Cookie |
3. 响应首部：响应首部只存在于响应报文中，提供服务器的信息以及对客户端的要求。
    首部|描述
    ---|---
    Age|响应存在时间
    Accept-Ranges |服务器接收的范围类型
    Cache-Control |服务器应遵循的缓存机制
    Expired |实体的过期时间
    Last-Modified |对象的最后修改时间
    Server |服务器软件的名称和版本
4. 实体首部：请求和响应都可能包含实体首部，实体首部提供了大量的实体信息。
	首部|描述
    ---|---
    Content-Encoding | 内容编码格式，告知客户端用这个编码格式解压
    Content-Language | 内容语言
    Content-Length | 内容尺寸，单位是字节
    Content-Type | 内容的MIME类型


### 301 和 302 状态码的区别

301是永久性重定向，302是暂时性重定向。

301表示旧地址A的资源已经被永久地移除了，搜索引擎在抓取新内容的同时也将旧的网址改变为重定向之后的网站。302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址**。

### 304 (Not Modified)状态码

当用户第一次请求资源A时，服务器会添加一个名为`Last-Modified`响应头，这个头说明了A的最后修改时间，浏览器会把A的内容以及最后的响应时间缓存下来，当用户第二次请求A时，在请求中包含一个名为`If-Modified-Since`请求头，它的值就是第一次请求时服务器通过`Last-Modified`响应头发送给浏览器的值，即资源A最后的修改时间。

`If-Modified-Since`请求头就是在告诉浏览器，我这里浏览器缓存的A最后修改时间是这个，你看看现在A最后修改时间是不是这个，如果还是，那么就不用响应这个请求了，我会把缓存里的内容直接显示出来。而服务器会获取`If-Modified-Since`值，与A当前的最后修改时间作对比，如果相同，则服务器返回304状态码，表示A与浏览器上次缓存的相同，无需再次发送，浏览器可以显示自己的缓存页面，如果比对不同，那么说明A已经改变，服务器会返回200状态码。

### readyState 0-4分别表示什么？

- `0(UNSENT)`：初始化，XMLHttpRequest 对象还没有完成初始化
- `1(OPENED)`：载入，XMLHttpRequest 对象开始发送请求
- `2(HEADERS_RECEIVED)`：载入完成，XMLHttpRequest 对象的请求发送完成
- `3(LOADING)`：解析，XMLHttpRequest 对象开始读取服务器的响应
- `4(DONE)`：数据传输已完成或传输过程中出现问题

### 200、403、404、500 和 503 状态码

- **200(OK)**：一切正常。一般用于GET和POST请求。
- **403(Forbidden)**：除非拥有授权否则服务器拒绝提供所请求的资源。
- **404(Not Found)**：告诉客户端所给的地址无法找到任何资源。
- **500(Internal Server Error)**：服务器错误。
- **503(Service Unavailable)**：表示服务器由于在维护或已经超载而无法响应。

### 安全

[戳我查看](https://github.com/SanQiG/Front-End-Interview-Summarize/blob/master/%E7%BD%91%E7%BB%9C%E3%80%81%E6%B5%8F%E8%A7%88%E5%99%A8/%E5%AE%89%E5%85%A8.md)
